#addin nuget:?package=Cake.Npm
#load "utilities.cake"

const string CoverageFolder = "./coverage_results/";
const string MainSolution = "../Crest.sln";

string configuration = Argument("configuration", "Release");
bool isLocalBuild = BuildSystem.IsLocalBuild;
string target = Argument("target", "Default");
string version = isLocalBuild ? "local" : EnvironmentVariable("APPVEYOR_BUILD_NUMBER");

var msBuildSettings = new DotNetCoreMSBuildSettings
{
    NoLogo = true
};

var buildSettings = new DotNetCoreBuildSettings
{
    Configuration = configuration,
    MSBuildSettings = msBuildSettings,
    NoRestore = true
};

var testSettings = new DotNetCoreTestSettings
{
    Configuration = configuration,
    Filter = "Category!=Integration",
    NoBuild = true,
    NoRestore = true
};

Task("Build")
    .Does(() =>
{
    DotNetCoreBuild(MainSolution, buildSettings);
});

Task("BuildAndTestTools")
    .Does(() =>
{
    foreach (var solution in GetFiles("../tools/*.sln"))
    {
        DotNetCoreBuild(solution.FullPath, buildSettings);
    }

    foreach (var project in GetFiles("../tools/*.UnitTests/*.csproj"))
    {
        DotNetCoreTest(project.FullPath, testSettings);
    }
});

Task("ExcludeDryIocFromStyleCop")
    .IsDependentOn("RestorePackages")
    .Does(() =>
{
    var packagesDirectory = GetNugetPackageDirectory();
    var filePattern = packagesDirectory.FullPath + "/dryioc.internal/*/contentFiles/cs/*/DryIoc/*.cs";
    foreach (var file in GetFiles(filePattern))
    {
        var backup = file.GetDirectory().CombineWithFilePath("../" + file.GetFilename() + ".original");
        if (!FileExists(backup))
        {
            Information("Modifying {0}", file);
            CopyFile(file, backup);
            string contents = System.IO.File.ReadAllText(file.FullPath);
            System.IO.File.WriteAllText(file.FullPath, "// <auto-generated/>\n" + contents);
        }
    }
});

Task("IntegrationTests")
    .IsDependentOn("Build")
    .Does(() =>
{
    // Verbosity = DotNetCoreVerbosity.Quiet doesn't seem to work, so we'll add
    // it ourselves
    var settings = new DotNetCoreTestSettings
    {
        ArgumentCustomization = args => args.Append("--verbosity quiet"),
        Configuration = configuration,
        Filter = "Category=Integration",
        NoBuild = true,
        NoRestore = true
    };

    Parallel.ForEach(GetFiles("../test/**/*.csproj"), project =>
    {
        // Specify the path to the test adapter to avoid a warning that no tests
        // were discovered because we filtered them all out
        settings.TestAdapterPath = project.GetDirectory().CombineWithFilePath("./bin/" + configuration + "/netcoreapp2.0/").FullPath;
        DotNetCoreTest(project.FullPath, settings);
    });
});

Task("Pack")
    .Does(() =>
{
    string[] projects = new[]
    {
        "../src/Crest.Abstractions/Crest.Abstractions.csproj",
        "../src/Crest.Core/Crest.Core.csproj",
        "../src/Crest.Host/Crest.Host.csproj",
        "../src/Crest.Host.AspNetCore/Crest.Host.AspNetCore.csproj",
        "../src/Crest.OpenApi/Crest.OpenApi.csproj",
        "../tools/Crest.Analyzers/Crest.Analyzers.csproj",
        "../tools/Crest.OpenApi.Generator/Crest.OpenApi.Generator.csproj"
    };

    var packSettings = new DotNetCorePackSettings
    {
        Configuration = configuration,
        MSBuildSettings = msBuildSettings,
        NoBuild = true,
        NoRestore = true,
        OutputDirectory = "./artifacts/",
        VersionSuffix = version
    };

    Parallel.ForEach(projects, project =>
    {
         DotNetCorePack(project, packSettings);
    });
});

Task("RestorePackages")
    .Does(() =>
{
    DotNetCoreRestore(MainSolution);

    // We have to use the old style restore for the VSIX project so that the
    // tasks are downloaded for the rest of the dotnet commands to work
    NuGetRestore("../tools/Crest.Analyzers.Vsix/packages.config", new NuGetRestoreSettings
    {
        PackagesDirectory = "../tools/packages"
    });

    foreach (var solution in GetFiles("../tools/*.sln"))
    {
        DotNetCoreRestore(solution.FullPath);
    }
});

Task("RestoreSwaggerUI")
    .Does(() =>
{
    var settings = new NpmInstallSettingsWithPrefix();
    settings.AddPackage("swagger-ui-dist", "3.0.18");
    NpmInstall(settings);

    string[] files = new[]
    {
        "./node_modules/swagger-ui-dist/swagger-ui.css",
        "./node_modules/swagger-ui-dist/swagger-ui-bundle.js",
        "./node_modules/swagger-ui-dist/swagger-ui-standalone-preset.js"
    };

    foreach (string file in files)
    {
        CompressFile(file, "../src/Crest.OpenApi/SwaggerUI/");
    }
});

Task("ShowTestReport")
    .WithCriteria(isLocalBuild)
    .IsDependentOn("TestWithCover")
    .Does(() =>
{
    ReportGenerator(GetFiles(CoverageFolder + "*.xml"), "./coverage_report");
    if (IsRunningOnWindows())
    {
        StartAndReturnProcess(
            "cmd",
            new ProcessSettings
            {
                Arguments = ProcessArgumentBuilder.FromString("/c start ./coverage_report/index.htm")
            });
    }
});

Task("TestWithCover")
    .IsDependentOn("Build")
    .Does(() =>
{
    var coverSettings = new OpenCoverSettings
    {
        LogLevel = OpenCoverLogLevel.Warn,
        OldStyle = true,
        Register = "Path64",
        ReturnTargetCodeOffset = 0
    };

    coverSettings.Filters.UnionWith(new[]
    {
        "+[Crest.*]*",
        "-[*]DryIoc.*",
        "-[*]ImTools.*",
        "-[*]FastExpressionCompiler.*",
        "-[*]*.Logging.*"
    });

    EnsureDirectoryExists(CoverageFolder);
    CleanDirectory(CoverageFolder);

    StartProcess("regsvr32", "/s /n /i:user ./tools/OpenCover/tools/x64/OpenCover.Profiler.dll");

    Parallel.ForEach(GetFiles("../test/**/*.csproj"), project =>
    {
        OpenCover(
            c => c.DotNetCoreTest(project.FullPath, testSettings),
            CoverageFolder + project.GetFilenameWithoutExtension() + ".xml",
            coverSettings
        );
    });
});

Task("UnitTests")
    .IsDependentOn("Build")
    .Does(() =>
{
    foreach (var project in GetFiles("../test/**/*.csproj"))
    {
        DotNetCoreTest(project.FullPath, testSettings);
    }
});

Task("UploadTestReport")
    .WithCriteria(!isLocalBuild)
    .IsDependentOn("TestWithCover")
    .Does(() =>
{
    Information("Installing tool");
    var toolPath = new DirectoryPath("./tools/coveralls");
    StartProcess("dotnet", "tool install coveralls.net --version 1.0.0 --tool-path \"" + toolPath.FullPath + "\"");

    Information("Uploading reports");
    var inputFiles = string.Join(";", GetFiles(CoverageFolder + "*.xml").Select(f => "opencover=" + f.FullPath));

    var arguments = "--multiple";
    arguments += " --input " + inputFiles;
    arguments += " --useRelativePaths";
    arguments += " --commitId " + EnvironmentVariable("APPVEYOR_REPO_COMMIT");
    arguments += " --commitBranch " + EnvironmentVariable("APPVEYOR_REPO_BRANCH");
    arguments += " --commitAuthor \"" + EnvironmentVariable("APPVEYOR_REPO_COMMIT_AUTHOR") + "\"";
    arguments += " --commitEmail " + EnvironmentVariable("APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL");
    arguments += " --commitMessage \"" + EnvironmentVariable("APPVEYOR_REPO_COMMIT_MESSAGE") + "\"";
    arguments += " --jobId " + EnvironmentVariable("APPVEYOR_BUILD_NUMBER");
    arguments += " --repoTokenVariable COVERALLS_REPO_TOKEN";
    StartProcess(toolPath.CombineWithFilePath("csmacnz.Coveralls.exe"), arguments);
});

Task("Restore")
    .IsDependentOn("ExcludeDryIocFromStyleCop")
    .IsDependentOn("RestorePackages")
    .IsDependentOn("RestoreSwaggerUI");

Task("Default")
    .IsDependentOn("Restore")
    .IsDependentOn("Build")
    .IsDependentOn("BuildAndTestTools")
    .IsDependentOn("TestWithCover")
    .IsDependentOn("IntegrationTests")
    .IsDependentOn("ShowTestReport")
    .IsDependentOn("UploadTestReport")
    .IsDependentOn("Pack");

RunTarget(target);
